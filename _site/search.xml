<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Study Notes - Binary Search]]></title>
      <url>/my-blog/study%20notes/2020/08/29/binary-search/</url>
      <content type="text"><![CDATA[Binary search is a very efficient algorithm for finding an element in a sorted list.First we compare the middle element with the target. If the target is smaller than the middle element, we reduce our search space to the first half of the list. If the target is bigger than the middle element, we reduce our search space to the second half of the list. We will keep reducing our search space until we find the target or the search space reach its minimum size.There are two important rules for Binary Search:  we must reduce our search space after each iteration.  we must make sure that the target cannot be ruled out when we reduce the search space.Here is the code for a classical Binary Search:public int binarySearch(int[] array, int target){	if (array == null || array.length == 0){		return -1;	}	int left = 0;	int right = 0;	while (left &lt;= right){		int middle = left + (right - left) // 2;		if (target &lt; array[middle]){			right = middle - 1;		}		else if (target &gt; array[middle]){			left = middle + 1;		}		else{			// target == array[middle]			return middle;		}	}	return -1;}Time complexity is O(logn) because we reduced the search space by half during each iteration.Space complexity is O(1) because there is no extra space.We can also perform binary search in a sorted 2D matrix.A simple way to do this is to treat it as an array with mathematical operation.left = 0  right = the size of matrix - 1  middle = left + (right - left)/2When we looping through the matrix:current row = middle / column size  current col = middle % colum sizeHere is the code:public int[] binarySearchIn2DMatrix(int[][] matrix, int target){	if (matrix == null || matrix[0].length == 0){		return new int[] {-1, -1};	}	int row = matrix.length;	int col = matrix[0].length;	int left = 0;	int right = row * col - 1;	while (left &lt;= right){		int middle = left + (right - left)/2;		int r = middle / col;		int c = middle % col;		if (target &lt; matrix[r][c]){			right = middle - 1;		}		else if (target &gt; matrix[r][c]){			left = middle + 1;		}		else{			return new int[] {r, c};		}	}	return new int[] {-1, -1};}The time complexity is O(logm×n) with a m×n matrix.What if there are duplicate elements and we need to find the index of the first occurrence of the target?Remember we must not rule out the target when we reduce our search space.When the value of the middle element is the same as the target, we should set the right index = middle instead of middle - 1, because the middle element may be the first occurrence of the target. If we set right = middle - 1, we may rule out the target.Furthermore, our left index should always less than the right index - 1. For example, If we have two elements [1, 2] and the target value is 2, we will never exit the loop if we use left &lt;= right - 1 as the condition.Here is the code:public int firstOccur(int[]  array, int target){	if (array == null || array.length == 0){		return -1;	}	int left = 0;	int right = array.length - 1;	while (left &lt; right - 1){		int middle = left + (right - left)/2;		if (array[middle] &lt; target){			left = middle; // or left = middle + 1;		}		else{			right = middle;		}	}	if (array[left] == target){		return left;	}	if (array[right] == target){		return right;	}	return -1;}What if we want to find the index of the last occurence of the target? In this case, when we find array[middle] == target, we need to set left = middle.Here is the code:public int lastOccur(int[]  array, int target){	if (array == null || array.length == 0){		return -1;	}	int left = 0;	int right = array.length - 1;	while (left &lt; right - 1){		int middle = left + (right - left)/2;		if (array[middle] &gt; target){			right = middle; // or right = middle - 1;		}		else{			left = middle;		}	}	if (array[right] == target){		return right;	}	if (array[left] == target){		return left;	}	return -1;}Now, let’s try to find the element that is closet to the target.For example, given a list = [1, 5, 8] and target = 6. The result will be 1 since 5 is closet to 6.Again, we should not rule out the middle element because it can be the target we want. Also, we should reduce our search space to two elements and compare them with the target. So the condition for the loop will be left &lt; right - 1.Here is the code:public int closest(int[] array, int target){	if (array == null || array.length == 0){		return -1;	}	int left = 0;	int right = array.length - 1;	while (left &lt; right - 1){		int middle = left + (right - left)/2;		if (array[middle] &lt; target){			left = middle;		}		else if (array[middle] &gt; target){			right = middle;		}		else{			return middle;		}	}	if (Math.abs(array[left] - target) &lt;= Math.abs(array[right] - target)){		return left;	}	return right;}What if we want to find k closet elements to the target?We just need to find the index of the closet element. Then we find k closet elements from the middle to the side.Here is the code:public int kCloset(int[] array, int target){	if (array == null || array.length == 0){		return array;	}	int left = closest(array, target);	int right = left + 1;  	int[] result = new int[k];	for (int i = 0; i &lt; k; i ++){		// We can move our left pointer when		// 1. Right index is out of bound		// 2. Left index is not out out of bound and array[left] is closer to the target		if (right &gt;= array.length || left &gt;= 0 &amp;&amp; target - array[left] &lt;= array[right] - target){			result[i] = array[left--];		}		else{			result[i] = array[right++];		}	}	return result;}The time complexity will be O(logn + k).Now, let’s try to find the smallest element that is larget than the target.Again, we should not rule out the target. When array[middle] is larget than the target, it can still be the reuslt we want. Therefore right = mid instead of mid - 1.Here is the code:public int smallestElementLargetThenTarget(int[] array, int target){	if (array == null || array.length == 0){		return -1;	}	int left = 0;	int right = array.length - 1;	while (left &lt; right - 1){		int middle = left + (right - left)/2;		if (array[middle] &lt;= target){			left = middle + 1;		}		else{			right = middle;		}	}	if (array[left] &gt; target){		return left;	}	if (array[right] &gt; target{		return right;	}	return - 1;}Now given a dictionary of unkown size, and the number in this dictionary is sorted in ascending order. How can we use binary search to find the target?We need to find the right index of this dictionary. Here is a simple way to do this.public int searchInUnknownSizedSortedArray(Dictionary dict, int target){	if(dict == null){		return -1;	}	int left = 0;	int right = 1;	while(dict.get(right) != null &amp;&amp; dict.get(right) &lt; target){		left = right;		right = 2 * right;	}	return binarySearch(dict, left, right, target);}public int binarySearch(Dictionary dict, int left, int right, int target){	while (left &lt;= right){		int mid = left + (right - left)/2;		if (dict.get(mid) == null || dict.get(mid) &gt; target){			right = mid - 1;		}		else if (dict.get(mid) &lt; target){			left = mid + 1;		}		else{			return mid;		}	}	return - 1;}]]></content>
      <categories>
        
          <category> Study Notes </category>
        
      </categories>
      <tags>
        
          <tag> Algorithm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Introduction to in-toto]]></title>
      <url>/my-blog/projects/2020/07/04/in-toto-summary/</url>
      <content type="text"><![CDATA[This is a short abstract of in-toto, a framework to secure the integrity of software supply chains. It is a project from Secure System Lab that I am participating as a Student Researcher now.  I also made a short video in Chinese: link  我也做了一个中文版本的演示视频：链接First, what is a software supply chain and why is it important?The software supply chain is a series of steps to make software run in the end-users system. It may include steps such as test, build, and package. It is important because if someone compromise the supply chain, attacker can hide and distribute malware to a significant number of users, given the app’s popularity. Microsoft has a well explained short video about supply chain attack, you can view it here.Then the question is, how can we protect the software supply chain? Citing from Microsoft’s document above, one approach is to “deploy strong code integrity policies to allow only authorized apps to run.” The role of in-toto is similar to this. In-toto secures the software supply chain by specifying information of each step and who is authorized to carry out each step.I will use in-toto demo to help understand how in-toto works. In this demo, we need to perform all steps of a simple software supply chain: Alice is the owner of this project, Bob is the developer, and Carl packages the software. Bob and Carl can also be called as project functionaries, who will carry out the steps of the supply chain.First, Alice needs to create a supply chain layout. Supply chain layout is a signed file that includes the details and requirements of each step. It also includes a list of the functionaries who are in charge of carrying out each step. For this demo, it includes Bob’s and Carl’s public key. The layout file of this demo includes the following data:It will be signed with owner’s private key. In this demo, it is Alice’s private key.			"signatures": [			{				"keyid": "556caebdc0877eed53d419b60eddb1e57fa773e4e31d70698b588f3e9cc48b35",				"sig": "ad773a4d62d8e42cc3f6e6053089cd702d6928c9972f0b3d41f373bca5fe6971c5a1ed120256d37b06bbb60e4557a1b052fe5f81409881b51a8b4c663413d056101e14ae9f81e0a9ef8490f2c2be4f1aa55701de855120c5874a16ff36852e0d8b02fb07708620360f45353e4e1f5c14ac24e13d14ac8e41eb9519a4bcc33ee4405980f98bb30de0d726e114079277db3716790b1a099e20a323b7f66aafe306adbf208439860404759378906b2ee03ea95ae99ff677759b4f7b6822811185f1ea6931bcbf26638d2b86c26a40d4a076ddff0ddf1380302a254e24581e94873518d7cb529d505b6abc385f8991988d852095fe74331855ef584b7e06897e83d1740a580d8d3da66a8d97e9f6067a8172cf00b06d916104f59db059b5b10f319089b198ce6c7e7922509505c0808fafd7e635210b9b36be7acbf34a8f310947db332a7e1258313a1bfd38634c269667b4a0d216a463200a088ec2eda24fa2c34d44b22df1882c3ba3832519e27d77e815cf74075d1742731519b4acb866dbbde2"			}		]	The format of the layout will look like this:			{ 			"_type" : "layout",			"expires" : "&lt;EXPIRES&gt;",			"readme": "&lt;README&gt;",			"keys" : {				"&lt;KEYID&gt;" : "&lt;PUBKEY_OBJECT&gt;"			},			"steps" : [				"&lt;STEP&gt;",				"..."			],			"inspect" : [				"&lt;INSPECTION&gt;",				"..."			]		}	The “expires” section will specify the expiration date, and in default it will be one month after the layout is created. The “steps”” section contain a list of restrictions for each steps. The “inspect” section also contain a list of restrictions for each step within the link, but it will be used in the final verification by the client.  The “keys” section contain a list of public keys. In this demo, it will contains Bob’s and Carl’s public keys.To keep this blog short, I will only show the detail of steps. The inspect section is somehow similar to the step section. You can view the difference in in-toto docs.In this demo, Bob will clone foo.py from GitHub and update its version number.In the layout file, Alice will specify the “clone” step as the following:			{			"_type": "step",			"expected_command": [				"git",				"clone",				"https://github.com/in-toto/demo-project.git"			],			"expected_materials": [],			"expected_products": [				[					"CREATE",					"demo-project/foo.py"				],				[					"DISALLOW",					"*"				]			],			"name": "clone",			"pubkeys": [				"776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b08453f5"			],			"threshold": 1		}	The “epxected_command” field include the command that Bob will run to clone the code from GitHub. The “expected_materials” and “expected_products” fields contain a list of ARTIFACT_RULES to ensure that materials and products are not changed. Since Bob has nothing before he clone the code, there will be no materials. After cloning the code, Bob will create “foo.py” locally as product. The “name” field is just the name of this step. The “pubkeys” section includes Bob’s public key. The “thresehold” field contains an integer specifying how many links are needed to verify this step.After Bob clone the code, a link file will be created:		{		"signatures": [			{			"keyid": "776a00e29f3559e0141b3b096f696abc6cfb0c657ab40f441132b345b08453f5",			"sig": "a520c8cd74ab156d4bd1f1b9b12dd4d06d9c80cc10e2a82f7b0f3a08f62365d8133a6cc991df150912f6da790eec6d71573cbc613bf6b359d25806bccd2c50c78c198fc1b11f86bc261841e938ce8ca733247949dc2e9924181b8d21b1d36f4e58720c95de831ab7c88e1b637a9d7170e7e53f4188bad6370a8eb1a50dc6e6fab519dd29b1d45cbe71a5207906fa44b8b856a773b317921fa6967a8deb4b1732a6c9e93d73e87578277cdc7abe2c619cc1128c459e794bc4bedf8385c62b86f99c7320e913a6b290e7404e24ead2053046ca103e01b29970f9623e8959b1deca0acc897799d15cfaca689621cd30fde5bdbcf191ab48bea7dd9b4d8d9b8b81324a6f0456ba7343b5ae729cdca8c9c278a367465358741098aa67f13a148ca56f8456d8403b35640e2c829797c2f1f1e49e5a9d5881f465728949fbd24c110532056ec1c75fddd13304f76334d3551ba03feba926f94ae7c41ad50080a710a0fce703c5f6aeaa5a0b503b8235de80f8f3cc648880fc103b87bd73483d1891580f"			}		],		"signed": {			"_type": "link",			"byproducts": {			"return-value": 0,			"stderr": "",			"stdout": ""			},			"command": [				"git",				"clone",				"https://github.com/in-toto/demo-project.git"			],			"environment": {},			"materials": {},			"name": "clone",			"products": {				"demo-project/foo.py": {				"sha256": "ebebf8778035e0e842a4f1aeb92a601be8ea8e621195f3b972316c60c9e12235"				}			}		}	}	This link file will be singed with Bob’s private keys. It also includes the name of the step, the products, the materials, Bob’s command for cloning the code, and Bob’s public key.After all the steps are carried out, the client will have the layout file and all the link files. Then the client can use these files to verify any unexpected changes in the supply chain.This is just a very rough illustration of how in-toto works, and I have to admit that I am not a good writer. I may come back to revise this blog sometime later. You can also check the full, well explained document of in-toto here.]]></content>
      <categories>
        
          <category> Projects </category>
        
      </categories>
      <tags>
        
          <tag> in-toto </tag>
        
          <tag> Security </tag>
        
          <tag> Python </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[The Brain—is wider than the Sky—]]></title>
      <url>/my-blog/misc/2020/07/01/The-Brain-is-wider-than-the-Sky/</url>
      <content type="text"><![CDATA[前段时间玩素晴日发现的一首的诗  The Brain—is wider than the Sky—For—put them side by side—The one the other will containWith ease—and you—beside—  The Brain is deeper than the sea—For—hold them—Blue to Blue—The one the other will absorb—As sponges—Buckets—do—  The Brain is just the weight of God—For—Heft them—Pound for Pound—And they will differ—if they do—As Syllable from Sound—  Emily Dickinson, c. 1862虽然想自己翻译一下，但始终没达到理想的效果，就用了游戏内的汉化  我们的脑袋比这片天空更加广阔来，你来试试看……天空被嗖嗖地吸进脑袋里了…… 然后……连你也吸了进来……  我们的脑袋比海还要深……来，将两份蔚蓝重合起来……大海便被嗖嗖地吸进了脑袋里……就像是海绵吸水一样……  我们的脑袋和上帝一样重来，正确地测测看……要说有什么不同，那就是……话语和声音的不同素晴日让我惊讶的地方还有偏在转生这个概念——“世界只需要一个灵魂”没想到以前的脑洞已经被别人提出来了，似乎是一个日本东大教授在他书中提到的 当时思考死亡的时候，想到转生这个概念，然后突发奇想，如果转生不受时间约束，是否可能转生到过去？如果这个前提成立的话，那同一个时间不是可能会出现两个“我”？ 如果这么无限轮回下去，同个时间可能出现三个“我”，四个“我”… 甚至全世界都是“我”的转生。这样的话，世界只需要一个灵魂。]]></content>
      <categories>
        
          <category> Misc </category>
        
      </categories>
      <tags>
        
          <tag> Games </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hello, World!]]></title>
      <url>/my-blog/misc/2020/07/01/Hello,-World/</url>
      <content type="text"><![CDATA[The beginning of my journey]]></content>
      <categories>
        
          <category> Misc </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
